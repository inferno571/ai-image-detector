
import { GoogleGenAI, Type, Modality } from "@google/genai";
import type { AnalysisResult } from '../types';
import { Classification } from '../types';

if (!process.env.API_KEY) {
  console.error("API_KEY environment variable not set. Please set it to use the Gemini API.");
}

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY! });

const fileToBase64 = (file: File): Promise<string> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      const result = reader.result as string;
      // remove the data:image/...;base64, part
      resolve(result.split(',')[1]);
    };
    reader.onerror = (error) => reject(error);
  });
};

export const analyzeImageForAIContent = async (imageFile: File): Promise<AnalysisResult> => {
  try {
    const base64Image = await fileToBase64(imageFile);

    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: {
        parts: [
          {
            inlineData: {
              mimeType: imageFile.type,
              data: base64Image,
            },
          },
          {
            text: `Analyze this image meticulously. Determine if it is a real photograph or if it has been generated by an AI. Look for common AI artifacts like unnatural textures, inconsistent lighting, anatomical errors in humans/animals, or garbled text. Provide a classification and a brief reasoning for your conclusion.`,
          },
        ],
      },
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            classification: {
              type: Type.STRING,
              enum: [Classification.REAL, Classification.FAKE, Classification.UNCERTAIN],
              description: 'The classification of the image.',
            },
            reasoning: {
              type: Type.STRING,
              description: 'A brief explanation for the classification, highlighting key visual evidence.',
            },
          },
          required: ["classification", "reasoning"],
        },
      },
    });

    const text = response.text.trim();
    if (!text) {
        throw new Error("Received an empty response from the API.");
    }

    const parsedResult: AnalysisResult = JSON.parse(text);
    return parsedResult;
  } catch (error) {
    console.error("Error analyzing image with Gemini API:", error);
    if (error instanceof Error && error.message.includes('API key not valid')) {
       throw new Error("The configured Gemini API key is invalid or missing.");
    }
    throw new Error("Failed to communicate with the AI model.");
  }
};

export const highlightArtifacts = async (imageFile: File, reasoning: string): Promise<string> => {
  try {
    const base64Image = await fileToBase64(imageFile);

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image-preview',
      contents: {
        parts: [
          {
            inlineData: {
              data: base64Image,
              mimeType: imageFile.type,
            },
          },
          {
            text: `Based on the following reasoning: "${reasoning}", please draw prominent, thick, red circles around the most obvious AI-generated artifacts in the image. Return only the annotated image.`,
          },
        ],
      },
      config: {
          responseModalities: [Modality.IMAGE, Modality.TEXT],
      },
    });

    for (const part of response.candidates[0].content.parts) {
      if (part.inlineData) {
        return `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
      }
    }
    
    throw new Error("The AI did not return a highlighted image.");

  } catch (error) {
    console.error("Error highlighting artifacts with Gemini API:", error);
    if (error instanceof Error && error.message.includes('API key not valid')) {
       throw new Error("The configured Gemini API key is invalid or missing.");
    }
    throw new Error("Failed to communicate with the image editing model.");
  }
};
